<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mohammad Amin</title>
  <link rel="stylesheet" href="../stylesheets/default.css">
  <link rel="stylesheet" href="../stylesheets/blog.css">
  <link href='https://fonts.googleapis.com/css?family=Roboto+Mono:400,700,500' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Francois+One' rel='stylesheet' type='text/css'>
</head>
<body>
  <header>
    <nav>
      <ul class = "nav-links">
        <li><a class="logo" href="../index.html">Mohammad Amin</a></li>
        <li><a href="../about.html">About Me</a> |</li> 
        <li><a href="index.html">Blog</a> |</li>
        <li><a href="../projects/index.html">Projects</a> |</li>
        <li><a href="#">Resume</a> |</li>
        <li><a href="../contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>


  <section class="blog-post">
      <h1>Sorting</h1>
      <h3>Merge sort, Quick sort, Bubble sort</h3>
      <h5>Dec 12, 2015</h5>

      <div class="blog-text">
        <h3>What is a sorting algorithm?</h3>
        <p>
          If you're a user of Ruby, you've probably used the #sort or #sort_by method a fair share of times.
          However, have you wondered about what is going on behind the scenes? How is it that Ruby "automagically"
          takes your array or hash values and returns them to you in a perfectly sorted manner of your choosing?
          Well the answer lies in the the sorting algorithm which is running behind the scenes. Sorting algorithm
          takes a list of items and systematically sorts them depending on the algorithm of the sort. Today, I
          will discuss three commonly used sorting algorithms, merge sort, quick sort, bubble sort.
        </p>
        
        <h3>Bubble Sort</h3>
        <p>
          Bubble sort is a simple sorting algorithm that repeatedly steps through the list to be sorted. It
          then compares each pair of adjacent items and swaps them if they are in the wrong order. The pass 
          through the list is repeated until no swaps are needed, which indicates that the  list is sorted. 
          The algorithm, which is a comparison sort, is named for the way smaller elements "bubble" to the top 
          of the list. Although the algorithm is simple, it is too slow and impractical for most problems.
          Here is a way to visualize a bubble sort:
        </p>
          
          <div class="example-images">
            <img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="Quick Sort">
          </div>

        <h3>Merge Sort</h3>
        <p>
          Mergesort is a divide and conquer algorithm that was invented by John von Neumann in 1945. It uses
          recursion in its implementation and is generally a much faster and efficient sorting algorithm than
          bubble sort is. The algorithm consists of the following: <br><br>
          1. Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted). <br>
          2. Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.
          <br><br>
          Here is a visual:
        </p>

        <div class="example-images">
          <img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="Merge Sort">
        </div>

        <h3>Quick Sort</h3>
        <p>
          Quick sort is the sort that Ruby uses by default in its implementation. Developed by Tony Hoare in 
          1959, it is still a commonly used algorithm for sorting. When implemented well, it can be about two 
          or three times faster than its main competitors, merge sort andheapsort. Here is the general algorithm
          for a quick sort: <br><br>

          1. Pick an element, called a pivot, from the array. <br>
          2. Reorder the array so that all elements with values less than the pivot come before the pivot, 
          while all elements with values greater than the pivot come after it (equal values can go either way).
          After this partitioning, the pivot is in its final position. This is called the partition operation. <br>
          3. Recursively apply the above steps to the sub-array of elements with smaller values and separately to
          the sub-array of elements with greater values.
          <br><br>
          Here is a visual:
        </p>

        <div class="example-images">
          <img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif" alt="Quick Sort">
        </div>

      <h3>Final Remarks</h3>
        <p>
          In the above examples, I have given high level examples of three sorting algorithms, all of which
          are unique in their own way and have different use cases. To find out which to use, or when to use it,
          do a little more research as you will definetly run across these at some point in your programming
          career. Also, <a href="https://www.wikipedia.org/">wikipedia</a> is a great source of learning more
          about the details of each sorting algorithm I discussed and much more.
        </p>
  </section>


<footer>
    <div class="footer-links">
        <a href="https://twitter.com/betterxhalf"><img src="../imgs/social/twitter.png" alt="Twitter"></a>
        <a href="https://www.facebook.com/singmo"><img src="../imgs/social/facebook.png" alt="FaceBook"></a>
        <a href="https://www.linkedin.com/pub/mohammad-amin/a8/485/813"><img src="../imgs/social/linkedin.png" alt="LinkedIn"></a>
        <a href="https://github.com/malamin92"><img src="../imgs/social/github.png" alt="Github"></a>
    </div>
    <p>Â©<span class="copyright">2015 Mohammad Amin</span></p>
  </footer>
</body>
</html>